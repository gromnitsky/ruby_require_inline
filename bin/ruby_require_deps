#!/usr/bin/env ruby

require 'getoptlong'

require 'ruby_parser'

require_relative '../lib/ruby_require_inline/version'
require_relative '../lib/ruby_require_inline/depswalk'

$conf = {
  mode: 'tree',               # also: flat
  verbose: 0,
  deps_paths: [],
  output: $stdout,
  input: nil
}



def usage ec = 0
  stream = ec == 0 ? $stdout : $stderr
  stream.puts "Usage: #{File.basename $0} [-o output] input"
  exit ec
end



opts = GetoptLong.new(['--help', '-h', GetoptLong::NO_ARGUMENT],
                      ['--flat', GetoptLong::NO_ARGUMENT],
                      ['-v', GetoptLong::NO_ARGUMENT],
                      ['--version', '-V', GetoptLong::NO_ARGUMENT],
                      ['-p', GetoptLong::REQUIRED_ARGUMENT],
                      ['-o', GetoptLong::REQUIRED_ARGUMENT])

begin
  opts.each do |opt, arg|
    case opt
    when '--help'
      usage
    when '-v'
      $conf[:verbose] += 1
    when '--flat'
      $conf[:mode] = 'flat'
    when '--version'
      puts RubyRequireInline::VERSION
      puts $LOAD_PATH
      exit 0
    when '-o'
      $conf[:output] = arg
    when '-p'
      $conf[:deps_paths] << arg
    end
  end
rescue GetoptLong::InvalidOption
  usage 1
end

usage 1 if ARGV.size == 0
$conf[:input] = ARGV[0]



dir_orig = Dir.pwd
Dir.chdir File.dirname $conf[:input]
$conf[:input] = File.basename $conf[:input]

dw = RubyRequireInline::DepsWalk.new $conf[:deps_paths], $conf[:input]
dw.start do |file, level, not_found|
  indent = $conf[:mode] == 'tree' ? '  ' * level : ''

  # open output so late because we don't want to destroy the output file
  # for nothing if there was an error in cl params
  if $conf[:output] != $stdout && !$conf[:output].is_a?(IO)
    $conf[:output] = File.open File.join(dir_orig, $conf[:output]), 'w+'
  end

  $conf[:output].printf "%s%s%s\n", indent, file, not_found ? " (not local?)" : ""
  $conf[:output].flush if $conf[:output] == $stdout
end
